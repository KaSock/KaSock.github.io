[{"id":"0ac08f58ad06e70a5e63949e85ce8601","title":"Unity音游实例","content":"本文用于粗略的记录下自制一个基于Unity的音乐游戏\n\n待更新\n\n\n\n\n\n","slug":"UnityMusic","date":"2022-06-30T03:05:40.000Z","categories_index":"Unity","tags_index":"Unity","author_index":"KaSock"},{"id":"9587744b030fd9730b7355dceb5c2274","title":"Arcaea破解版v3.12","content":"《Arcaea》（韵律源点）是lowiro开发的一款三维立体音乐游戏，当前位于iOS平台、Android平台和Nintendo Switch平台。游戏的移动版发布于2017年3月9日，NS版已于2021年5月18日上线。游戏以独特的三维游戏模式知名，带有搭档系统且部分搭档拥有其个人剧情，剧情围绕光和对立展开。游戏带有World模式，可以通过游玩自由或指定歌曲来获取进展，获得曲目，搭档等要素。游戏带有一个潜力值系统，可以计算玩家历史以来游玩曲目的信息，获得一个衡量自身实力的数值。\n\n\n\n下载地址(官方正版)Google Play商店\n616sb下载 (推荐)\nQooAPP下载\nTapTap下载\nIOS商店\n下载地址(破解版)百度网盘\nOneDrive\n天翼网盘\n修改内容\n全曲包解锁\n\n美化界面\n\n愚人节歌曲\n\n证书去除\n\n\n画面截图\n\n\n\n当前破解版对应正版版本：3.12\n特殊说明这个破解版的作者并不是我，这是YouTube上的一位UP主做的Fanmade版本的Arcaea。\n这个版本的Arcaea如果想实现换人物等在线功能的话可以尝试用这个版本搭建Arcaea本地服务器，IOS也可以使用这个项目搭建服务器。\n\n","slug":"ArcHack","date":"2022-05-25T03:32:10.000Z","categories_index":"手机软件","tags_index":"破解","author_index":"KaSock"},{"id":"95801a56b8faceb6cfed73d9d5b08b74","title":"扫雷游戏的实现","content":"记录一下利用C语言写的扫雷小游戏，小白都能看懂的记录博客\n算是写的第二个小游戏了，第一个是三子棋小游戏\n之前写三子棋的时候还没搭建这个博客，所以没来得及记录思路\n本文可能会有大量文字和代码块，其次笔者文笔水平也不高，请谨慎观看！\n\"More haste, less speed\"\n\n\n框架一、创建game.c文件用来存放游戏函数的实现二、创建game.h头文件来声明游戏引用三、创建main.c文件作为游戏运行的入口\n游戏逻辑一、扫雷游戏需要两张棋盘，所以需要创建两个char类型二维数组，一个作为玩家看见的以及用于排查雷信息的棋盘，另一个作为地雷的布置和显示地雷信息的棋盘。二、在放置地雷的棋盘设定规则，设定0表示不是雷，1表示雷。三、在点击任意坐标后，应判断坐标位置一圈的8个点有多少地雷，但是在边界时可能就会发生下标越界，所以在开辟两个数组的时候应该增大一圈，比如游戏棋盘的9*9，那数组就开辟11*11的空间，且扩大一圈的数组元素全为0。四、在玩家看见的棋盘中，未揭开的坐标全部由*代替。\n游戏实现(9*9扫雷)一、绘制游戏游戏菜单1.实现游戏基本运行流程创建main函数\nint main()\n&#123;\n\tsrand((unsigned int)time(NULL));\n\tint input &#x3D; 0;\n\tdo\n\t&#123;\n\t\tmenu();                 &#x2F;&#x2F;游戏菜单\n\t\tprintf(&quot;请输入&gt;&gt;&quot;);\n\t\tscanf(&quot;%d\\n&quot;, &amp;input);  &#x2F;&#x2F;接收用户输入\n\t\tswitch (input)\n\t\t&#123;\n\t\tcase 1:\n\t\t\tgame();             &#x2F;&#x2F;扫雷游戏\n\t\t\tbreak;\n\t\tcase 0:                 &#x2F;&#x2F;退出循环同时while(0)结束程序运行\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&quot;选择错误，重新选择\\n&quot;);   &#x2F;&#x2F;break但while非0继续进入菜单\n\t\t\tbreak;\n\t\t&#125;\n\t&#125; while (input);            &#x2F;&#x2F;游戏的循环进行\n\n\treturn 0;\n&#125;\n\n2.绘制游戏菜单void menu()\n&#123;\n\tprintf(&quot;*********************\\n&quot;);\n\tprintf(&quot;*****   1.play  *****\\n&quot;);\n\tprintf(&quot;*****   0.exit  *****\\n&quot;);\n\tprintf(&quot;*********************\\n&quot;);\n&#125;\n\n二、实现游戏功能1.定义棋盘的大小在game.h中根据逻辑三定义行和列\n#include&lt;stdio.h&gt;\t\t\t\t&#x2F;&#x2F;在这个.h文件中引用头文件则可以免去每个源文件都引用一遍的麻烦\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\n\n#define ROW  9\t\t\t\t\t&#x2F;&#x2F;真正的棋盘\n#define COL  9\t\t\t\t\t&#x2F;&#x2F;ROW行 COL列\n\n#define ROWS ROW + 2\t\t\t&#x2F;&#x2F;数组棋盘\n#define COLS COL + 2\n\n2.初始化棋盘声明并定义InitBoard函数首先理清逻辑，定义这样一个函数，参数需要四个(数组，行，列，设定值)设定值用于设定初始化0和*然后在game.h中定义函数，在game.c中实现\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set);\t\t&#x2F;&#x2F;char set 用于设置初始化值\ngame.h\n\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set)\n&#123;\n\tfor (int i &#x3D; 0; i &lt; rows; i++)        &#x2F;&#x2F;遍历循环赋值二维数组\n\t&#123;\n\t\tfor (int j &#x3D; 0; j &lt; cols; j++)\n\t\t&#123;\n\t\t\tboard[i][j] &#x3D; set;\t\t\t  &#x2F;&#x2F;使用set来保证通用性\n\t\t&#125;\n\t&#125;\n&#125;\ngame.c\n\n3.显示棋盘定义一个DisplayBoard函数来显示棋盘，然后同样在game.h里面声明\nvoid DisplayBoard(char board[ROWS][COLS], int row, int col)\n&#123;\n\tprintf(&quot;--------扫雷--------\\n&quot;);\t\t\n\t&#x2F;&#x2F;打印列号\n\tfor (int i &#x3D; 0; i &lt;&#x3D; col; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, i);\n\t&#125;\n\tprintf(&quot;\\n&quot;);\n\tfor (int i &#x3D; 1; i &lt;&#x3D; row; i++)\n\t&#123;\n\t\tprintf(&quot;%d &quot;, i);\t\t\t\t\t\t\t\t&#x2F;&#x2F;打印行号\n\t\tfor (int j &#x3D; 1; j &lt;&#x3D; col; j++)\n\t\t&#123;\n\t\t\tprintf(&quot;%c &quot;, board[i][j]);\t\t\t\t\t&#x2F;&#x2F;打印棋盘\n\t\t&#125;\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\n4.设置雷定义SetMine函数用来设置雷，设置一个count为雷数\nvoid SetMine(char mine[ROWS][COLS], int row, int col)\n&#123;\n\tint count &#x3D; EASY_COUNT;\t\t\t&#x2F;&#x2F;也可以用参数的方式设定雷数\n\twhile (count)\n\t&#123;\n\t\t&#x2F;&#x2F;生成随机下标去布置雷\n\t\tint x &#x3D; rand() % row + 1;\n\t\tint y &#x3D; rand() % col + 1;\n\t\tif (mine[x][y] &#x3D;&#x3D; &#39;0&#39;)\t\t&#x2F;&#x2F;判断坐标有无雷\n\t\t&#123;\n\t\t\tmine[x][y] &#x3D; &#39;1&#39;;\n\t\t\tcount--;\n\t\t&#125;\n\t&#125;\n&#125;\n\n5.排查雷定义FindMine函数用来找雷，传入mine数组和show数组进行操作\nvoid FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)\n&#123;\n\t&#x2F;&#x2F;用户输入想排查的坐标\n\t&#x2F;*检查坐标位置是不是雷\n\t\t1.是雷\t\t游戏结束\n\t\t2.不是雷\t游戏继续 统计坐标附近雷的数量 存储信息到show数组里\n\t*&#x2F;\n\n\tint x &#x3D; 0;\n\tint y &#x3D; 0;\n\tint win &#x3D; 0;\n\n\twhile (win&lt;row*col-EASY_COUNT&gt;)\n\t&#123;\n\t\tprintf(&quot;输入坐标排雷&gt;&gt;&quot;);\n\t\tscanf(&quot;%d%d&quot;, &amp;x, &amp;y);\t\t\t\t&#x2F;&#x2F;x(1-9) y(1-9)\n\n\t\tif (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col)\t&#x2F;&#x2F;检测输入合法性\n\t\t&#123;\n\t\t\tif (mine[x][y] &#x3D;&#x3D; &#39;1&#39;)\n\t\t\t&#123;\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t\tprintf(&quot;游戏结束\\n&quot;);\n\t\t\t\tDisplayBoard(mine, row, col);\t\t\t&#x2F;&#x2F;显示结束后的棋盘\n\t\t\t\tprintf(&quot;\\n&quot;);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;统计x,y周围雷的数量\n\t\t\t\tint count &#x3D; get_mine_count(mine, x, y);\n\t\t\t\tshow[x][y] &#x3D; count + &#39;0&#39;;\t\t\t\t&#x2F;&#x2F;将count的值放入对应x, y坐标内，int + &#39;0&#39;将整型转为字符型\n\t\t\t\tsystem(&quot;cls&quot;);\n\t\t\t\tDisplayBoard(show, row, col);\t\t\t&#x2F;&#x2F;查看排查情况\n\t\t\t\twin++;\n\t\t\t&#125;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;非法坐标，重新输入\\n&quot;);\n\t\t&#125;\n\t&#125;\n\tif (win &#x3D;&#x3D; row * col - EASY_COUNT)\t\t&#x2F;&#x2F;判断游戏是否胜利\n\t&#123;\n\t\tsystem(&quot;cls&quot;);\n\t\tprintf(&quot;\\n游戏胜利&quot;);\n\t\tDisplayBoard(mine, row, col);\n\t&#125;\n&#125;\n其中需要定义一个统计雷的函数，思路我写在了注释中\nstatic int get_mine_count(char mine[ROWS][COLS], int x, int y)\n&#123;\n\t&#x2F;&#x2F;此函数仅只用于FindMine函数，不用在头文件声明\n\n\t&#x2F;*分析\n\t*\tx-1, y-1\tx-1, y\t x-1,  y+1\n\t* \n\t\tx,\t y-1\tx,   y\t x,    y+1\n\n\t\tx+1  y-1\tx+1, y\t x+1,  y+1\n\t*&#x2F;\n\n\t&#x2F;&#x2F;思路 将附近八个坐标的字符加起来，然后减去8个字符0，得到的就是整型雷的个数\n\treturn\n\t\tmine[x - 1][y] +\n\t\tmine[x - 1][y - 1] +\n\t\tmine[x][y - 1] +\n\t\tmine[x + 1][y - 1] +\n\t\tmine[x + 1][y] +\n\t\tmine[x + 1][y + 1] +\n\t\tmine[x][y + 1] +\n\t\tmine[x - 1][y + 1] - 8 * &#39;0&#39;;\n&#125;\n三、拼接游戏功能在main.c中创建game函数用于拼接游戏功能，实现游戏\nvoid game()\n&#123;\n\tchar mine[ROWS][COLS] &#x3D; &#123;0&#125;;   &#x2F;&#x2F;存放布置的雷的信息\n\tchar show[ROWS][COLS] &#x3D; &#123;0&#125;;   &#x2F;&#x2F;存放排查出雷的信息\n\n\t&#x2F;&#x2F;初始化棋盘\n\tInitBoard(mine, ROWS, COLS, &#39;0&#39;);\n\tInitBoard(show, ROWS, COLS, &#39;*&#39;);\n\n\t&#x2F;&#x2F;打印棋盘\n\tsystem(&quot;cls&quot;);\n\tDisplayBoard(show, ROW, COL);\n\n\t&#x2F;&#x2F;布置雷\n\tSetMine(mine, ROW, COL);\n\n\t&#x2F;&#x2F;排查雷\n\tFindMine(mine, show, ROW, COL);\n&#125;\ngame.h全部内容\n#define _CRT_SECURE_NO_WARNINGS 1\n#include&lt;stdio.h&gt;\t\t\t\t&#x2F;&#x2F;在这个.h文件中引用头文件则可以免去每个源文件都引用一遍的麻烦\n#include&lt;stdlib.h&gt;\n#include&lt;time.h&gt;\n\n#define ROW  9\t\t\t&#x2F;&#x2F;真正的棋盘\n#define COL  9\t\t\t&#x2F;&#x2F;ROW行 COL列\n#define EASY_COUNT 10\t&#x2F;&#x2F;简单版本的雷数\n\n#define ROWS ROW + 2\t&#x2F;&#x2F;数组棋盘\n#define COLS COL + 2\n\n&#x2F;&#x2F;初始化棋盘\nvoid InitBoard(char board[ROWS][COLS], int rows, int cols, char set);\t\t&#x2F;&#x2F;char set 用于设置初始化值\n\n&#x2F;&#x2F;打印棋盘\nvoid DisplayBoard(char board[ROWS][COLS], int row, int col);\n\n&#x2F;&#x2F;设置雷\nvoid SetMine(char mine[ROWS][COLS], int row, int col);\n\n&#x2F;&#x2F;排雷\nvoid FindMine(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col);\n总结总而言之，这个游戏的实现并不困难，主要是实现每个功能的思路每个函数都不止一种写法比如检测一个坐标附近的八个坐标是否有雷的函数，那是我目前能想到的最好的一个方法了，之前也尝试过八个if，或者嵌套for，但是感觉还是这种最好。这篇博客到此就结束了，有任何问题可以评论，项目已经开源在Github上了。\n","slug":"Minesweeper","date":"2022-05-02T08:05:08.000Z","categories_index":"文章","tags_index":"C","author_index":"KaSock"},{"id":"e049525249fb73e31d0e6111c4222df5","title":"记录博客的搭建","content":"这里是一个小白的第一次搭建博客的过程，虽然可能看着很简单很基础，但是却因为网上教程的时效而报错了无数次\n但是最终还是安装成功了，并且安装上了这么好看的一个主题，就是作为前端小白，个性化网页方面就很头疼了\n\"Don't let your past dictate who you are, but let it be part of who you will become\"\n\n\n准备工作1.首先在Github上创建一个username.github.io的仓库(是用户名不是昵称)\n2.下载安装Githttps:&#x2F;&#x2F;git-scm.com&#x2F;downloads\n3.下载安装node.jshttp:&#x2F;&#x2F;nodejs.cn&#x2F;download&#x2F;\n4.安装Hexonpm install -g hexo-cli  &#x2F;  yarn global add hexo-cli\n\n开始搭建1. 创建博客文件夹，在根目录下打开Git Bash，初始化博客hexo init\n\n2. 修改_config.yml文件配置，使用Gitdeploy:\n  type: git\n  repo: https:&#x2F;&#x2F;github.com&#x2F;KaSock&#x2F;KaSock.github.io  &#x2F;&#x2F;这里填仓库的网址就行\n  # example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io\n  branch: master   &#x2F;&#x2F;这里新版GitHub创建的默认分支为main 按需修改\n3. 安装Git部署工具npm install hexo-deployer-git --save\n4. 部署博客hexo clean      &#x2F;&#x2F;清理\nhexo g          &#x2F;&#x2F;静态化\nhexo d          &#x2F;&#x2F;部署\n\n搭建完成Git完成后可在username.github.io网页中看见Hexo官方的默认博客主题，后续可进行个性化\n\n","slug":"record-blog","date":"2022-04-30T08:16:37.000Z","categories_index":"文章","tags_index":"日常","author_index":"KaSock"}]